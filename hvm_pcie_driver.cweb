@* HanoiVM PCIe Linux Driver (Character Device with MMIO Mapping) *@

@c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/pci.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/cdev.h>
#include <linux/io.h>

#define VENDOR_ID 0x1ABC
#define DEVICE_ID 0x1DEF
#define HVM_BAR    0  // PCI BAR 0

static void __iomem *bar_addr;
static struct pci_device_id hvm_ids[] = {
    { PCI_DEVICE(VENDOR_ID, DEVICE_ID), },
    { 0, }
};

MODULE_DEVICE_TABLE(pci, hvm_ids);

static struct pci_dev *pdev;
static struct cdev hvm_cdev;
static dev_t dev_num;
static struct class *hvm_class;

@* PCI probe function for detecting HanoiVM accelerator *@
@c
static int hvm_probe(struct pci_dev *dev, const struct pci_device_id *id) {
    int err;
    pdev = dev;
    err = pci_enable_device(dev);
    if (err) return err;

    err = pci_request_region(dev, HVM_BAR, "hvm_bar");
    if (err) return err;

    bar_addr = pci_iomap(dev, HVM_BAR, pci_resource_len(dev, HVM_BAR));
    if (!bar_addr) return -ENOMEM;

    alloc_chrdev_region(&dev_num, 0, 1, "hvmdev");
    cdev_init(&hvm_cdev, &fops);
    cdev_add(&hvm_cdev, dev_num, 1);
    hvm_class = class_create(THIS_MODULE, "hvm");
    device_create(hvm_class, NULL, dev_num, NULL, "hvm0");
    return 0;
}

@* PCI remove function to clean up *@
@c
static void hvm_remove(struct pci_dev *dev) {
    device_destroy(hvm_class, dev_num);
    class_destroy(hvm_class);
    cdev_del(&hvm_cdev);
    unregister_chrdev_region(dev_num, 1);
    pci_iounmap(dev, bar_addr);
    pci_release_region(dev, HVM_BAR);
    pci_disable_device(dev);
}

@* File operations: Write opcode and operand, trigger execution, read result *@
@c
static ssize_t hvm_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos) {
    uint8_t opcode;
    uint81_t operand;
    if (copy_from_user(&opcode, buf, 1)) return -EFAULT;
    if (copy_from_user(&operand, buf + 1, sizeof(uint81_t))) return -EFAULT;

    iowrite8(opcode, bar_addr + 0x0000);
    memcpy_toio(bar_addr + 0x1000, &operand, sizeof(uint81_t));
    iowrite8(1, bar_addr + 0x3000);  // CONTROL_REG
    return count;
}

static ssize_t hvm_read(struct file *file, char __user *buf, size_t count, loff_t *ppos) {
    uint8_t status = ioread8(bar_addr + 0x3001);
    if (status != 1) return -EAGAIN;
    uint81_t result;
    memcpy_fromio(&result, bar_addr + 0x2000, sizeof(uint81_t));
    if (copy_to_user(buf, &result, sizeof(uint81_t))) return -EFAULT;
    return sizeof(uint81_t);
}

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .read = hvm_read,
    .write = hvm_write,
};

@* Register the PCI driver *@
@c
static struct pci_driver hvm_driver = {
    .name = "hanoivm",
    .id_table = hvm_ids,
    .probe = hvm_probe,
    .remove = hvm_remove,
};

@c
static int __init hvm_init(void) {
    return pci_register_driver(&hvm_driver);
}

static void __exit hvm_exit(void) {
    pci_unregister_driver(&hvm_driver);
}

module_init(hvm_init);
module_exit(hvm_exit);
MODULE_LICENSE("MIT");
MODULE_AUTHOR("copyl-sys");
MODULE_DESCRIPTION("HanoiVM PCIe Ternary Accelerator Driver");
