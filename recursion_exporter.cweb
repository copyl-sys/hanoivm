@* recursion_exporter.cweb -- Extended recursion export with Axion AI annotations and ternary insight.

@c
#include "t81_core.h"
#include "hanoivm_stack.h"
#include "hanoivm_vm.h"
#include "axion_api.h"          // New: Axion AI interface
#include "json_export.h"

#define MAX_JSON_DEPTH 729

typedef struct {
    char function_name[81];
    int frame_index;
    int depth_level;
    T81Datum locals[MAX_LOCALS];
    int ternary_state;  // 1 = T+, 0 = T0, -1 = T−

    // New Axion metadata
    char axion_annotation[243];
    double axion_optimization_score;
    bool axion_suggested_collapse;
} RecursiveFrame;

typedef struct {
    RecursiveFrame frames[MAX_JSON_DEPTH];
    int total_depth;
} RecursionTrace;

static RecursionTrace global_trace;

/* Translate ternary state to symbol for easier HUD rendering */
const char* ternary_state_symbol(int state) {
    switch (state) {
        case 1:  return "T+";
        case 0:  return "T0";
        case -1: return "T−";
        default: return "UNKNOWN";
    }
}

/* Capture a single frame with Axion enrichment */
void capture_recursive_frame(HVMContext* ctx, const char* func_name, int depth) {
    if (depth >= MAX_JSON_DEPTH) return;

    RecursiveFrame* frame = &global_trace.frames[depth];
    strncpy(frame->function_name, func_name, 80);
    frame->frame_index = ctx->stack_ptr;
    frame->depth_level = depth;
    frame->ternary_state = get_ternary_state(ctx);

    for (int i = 0; i < MAX_LOCALS; i++) {
        frame->locals[i] = ctx->stack[ctx->stack_ptr].locals[i];
    }

    // Query Axion for runtime guidance
    axion_frame_optimize(ctx, frame->axion_annotation, sizeof(frame->axion_annotation));
    frame->axion_optimization_score = axion_predict_score(ctx);
    frame->axion_suggested_collapse = axion_suggest_tail_collapse(ctx);

    global_trace.total_depth = depth + 1;
}

/* Export entire trace to JSON for Looking Glass 3D render pipeline */
void export_recursion_trace(const char* output_path) {
    FILE* f = fopen(output_path, "w");
    if (!f) return;

    fprintf(f, "{\n  \"recursionTrace\": [\n");

    for (int i = 0; i < global_trace.total_depth; i++) {
        RecursiveFrame* frame = &global_trace.frames[i];
        fprintf(f, "    {\n");
        fprintf(f, "      \"function\": \"%s\",\n", frame->function_name);
        fprintf(f, "      \"frameIndex\": %d,\n", frame->frame_index);
        fprintf(f, "      \"depth\": %d,\n", frame->depth_level);
        fprintf(f, "      \"ternaryState\": \"%s\",\n", ternary_state_symbol(frame->ternary_state));
        
        // Axion annotations
        fprintf(f, "      \"axion\": {\n");
        fprintf(f, "        \"annotation\": \"%s\",\n", frame->axion_annotation);
        fprintf(f, "        \"optimizationScore\": %.4f,\n", frame->axion_optimization_score);
        fprintf(f, "        \"suggestedCollapse\": %s\n", frame->axion_suggested_collapse ? "true" : "false");
        fprintf(f, "      },\n");

        // T81 Locals
        fprintf(f, "      \"locals\": [\n");
        for (int j = 0; j < MAX_LOCALS; j++) {
            T81Datum d = frame->locals[j];
            fprintf(f, "        { \"type\": \"%s\", \"value\": \"%s\" }%s\n",
                t81_type_name(d.type), t81_to_string(&d),
                (j == MAX_LOCALS - 1 ? "" : ","));
        }
        fprintf(f, "      ]\n");

        fprintf(f, "    }%s\n", (i == global_trace.total_depth - 1 ? "" : ","));
    }

    fprintf(f, "  ]\n}\n");
    fclose(f);
}
