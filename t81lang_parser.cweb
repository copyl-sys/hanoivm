@* T81Lang Parser (t81lang_parser.cweb) *@

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "t81lang_lexer.cweb"

// AST Node Types
typedef enum {
    AST_PROGRAM,
    AST_FUNCTION,
    AST_STATEMENT,
    AST_RETURN,
    AST_ASSIGNMENT,
    AST_IDENTIFIER,
    AST_LITERAL,
    AST_BINARY_EXPR,
    AST_CALL,
    AST_TYPE
} ASTNodeType;

// AST Node Structure
typedef struct ASTNode {
    ASTNodeType type;
    char name[MAX_TOKEN_LEN];
    struct ASTNode* left;
    struct ASTNode* right;
    struct ASTNode* body;
    struct ASTNode* next;
} ASTNode;

// Parser State
static Token current;

void advance_token() {
    current = next_token();
}

int match_token(TokenType type) {
    if (current.type == type) {
        advance_token();
        return 1;
    }
    return 0;
}

ASTNode* create_node(ASTNodeType type, const char* name) {
    ASTNode* node = malloc(sizeof(ASTNode));
    node->type = type;
    strncpy(node->name, name ? name : "", MAX_TOKEN_LEN);
    node->left = node->right = node->body = node->next = NULL;
    return node;
}

ASTNode* parse_identifier() {
    if (current.type == TOKEN_IDENTIFIER) {
        ASTNode* id = create_node(AST_IDENTIFIER, current.lexeme);
        advance_token();
        return id;
    }
    return NULL;
}

ASTNode* parse_literal() {
    if (current.type == TOKEN_INTEGER_LITERAL ||
        current.type == TOKEN_FLOAT_LITERAL ||
        current.type == TOKEN_STRING_LITERAL ||
        current.type == TOKEN_TERNARY_LITERAL) {
        ASTNode* lit = create_node(AST_LITERAL, current.lexeme);
        advance_token();
        return lit;
    }
    return NULL;
}

ASTNode* parse_expression();

ASTNode* parse_term() {
    if (current.type == TOKEN_IDENTIFIER) return parse_identifier();
    if (current.type == TOKEN_INTEGER_LITERAL ||
        current.type == TOKEN_FLOAT_LITERAL ||
        current.type == TOKEN_STRING_LITERAL ||
        current.type == TOKEN_TERNARY_LITERAL) return parse_literal();
    return NULL;
}

ASTNode* parse_expression() {
    ASTNode* left = parse_term();
    while (current.type == TOKEN_OPERATOR) {
        char op[MAX_TOKEN_LEN];
        strncpy(op, current.lexeme, MAX_TOKEN_LEN);
        advance_token();
        ASTNode* right = parse_term();
        ASTNode* bin = create_node(AST_BINARY_EXPR, op);
        bin->left = left;
        bin->right = right;
        left = bin;
    }
    return left;
}

ASTNode* parse_return() {
    if (match_token(TOKEN_KEYWORD) && strcmp(current.lexeme, "return") == 0) {
        ASTNode* ret = create_node(AST_RETURN, "return");
        advance_token();
        ret->left = parse_expression();
        return ret;
    }
    return NULL;
}

ASTNode* parse_statement() {
    ASTNode* stmt = parse_return();
    if (!stmt) stmt = parse_expression();
    return stmt;
}

ASTNode* parse_function() {
    if (match_token(TOKEN_KEYWORD) && strcmp(current.lexeme, "fn") == 0) {
        advance_token();
        ASTNode* func = create_node(AST_FUNCTION, current.lexeme);
        if (match_token(TOKEN_IDENTIFIER)) {
            strncpy(func->name, current.lexeme, MAX_TOKEN_LEN);
            advance_token();
        }
        // TODO: parse parameters, return type, body
        return func;
    }
    return NULL;
}

ASTNode* parse_program() {
    ASTNode* root = create_node(AST_PROGRAM, "program");
    ASTNode* last = NULL;
    while (current.type != TOKEN_EOF) {
        ASTNode* fn = parse_function();
        if (last) last->next = fn;
        else root->body = fn;
        last = fn;
    }
    return root;
}

void print_ast(ASTNode* node, int depth) {
    if (!node) return;
    for (int i = 0; i < depth; i++) printf("  ");
    printf("%s (%d)\n", node->name, node->type);
    print_ast(node->left, depth + 1);
    print_ast(node->right, depth + 1);
    print_ast(node->body, depth + 1);
    print_ast(node->next, depth);
}

// Example usage
int main() {
    const char* code = "fn main() -> T81BigInt { return 123t81; }";
    set_source(code);
    advance_token();
    ASTNode* ast = parse_program();
    print_ast(ast, 0);
    return 0;
}
