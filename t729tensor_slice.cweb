@* t729tensor_slice.cweb â€” Extracts a subrange from a given dimension of a T729Tensor *@

@<Include Dependencies@>=
#include "t729tensor.h"
#include <stdlib.h>
#include <string.h>

@<Slice Tensor Implementation@>=
#define OP_T729_SLICE 0xE4

case OP_T729_SLICE: {
    // For now, use fixed dim/start/end (e.g., dim=0, start=0, end=2)
    TernaryHandle a = stack_pop();
    TernaryHandle r;
    t729tensor_slice(a, 0, 0, 2, &r);
    stack_push(r);
    break;
}
#define OP_T729_SLICE 0xE4
int t729tensor_slice(TernaryHandle h, int dim, int start, int end, TernaryHandle* result) {
    T729Tensor* t = (T729Tensor*)h.data;
    @<Bounds Check@>

    @<Compute Slice Shape and Size@>
    @<Allocate and Copy Slice Data@>

    T729Tensor* sliced = (T729Tensor*)malloc(sizeof(T729Tensor));
    sliced->rank = t->rank;
    sliced->shape = new_shape;
    sliced->data = new_data;

    result->base = BASE_729;
    result->data = sliced;
    return 0;

case OP_T729_SLICE: {
    // For now, use fixed dim/start/end (e.g., dim=0, start=0, end=2)
    TernaryHandle a = stack_pop();
    TernaryHandle r;
    t729tensor_slice(a, 0, 0, 2, &r);
    stack_push(r);
    break;
}
}

@<Bounds Check@>=
if (!t || dim >= t->rank || start < 0 || end > t->shape[dim] || start >= end)
    return -1;

@<Compute Slice Shape and Size@>=
int* new_shape = (int*)malloc(sizeof(int) * t->rank);
memcpy(new_shape, t->shape, sizeof(int) * t->rank);
new_shape[dim] = end - start;

size_t stride = 1;
for (int i = dim + 1; i < t->rank; ++i)
    stride *= t->shape[i];

size_t slice_size = (end - start) * stride;

@<Allocate and Copy Slice Data@>=
float* new_data = (float*)malloc(sizeof(float) * slice_size);
memcpy(new_data, t->data + start * stride, sizeof(float) * slice_size);
