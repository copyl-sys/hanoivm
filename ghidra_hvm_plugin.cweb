@* Ghidra Plugin for HanoiVM â€” Disassembler & Type-Aware Processor Integration *@

@c
#include <ghidra/ghidra_plugin.h>
#include <ghidra/program.h>
#include <ghidra/disassembler.h>
#include "disasm_hvm.h"  // Full recursive type disassembler for T81 and higher-order types

@<Plugin Metadata@>=
GHIDRA_PLUGIN("HanoiVM Disassembler", "copyl-sys", "AI-native ternary instruction format disassembler")

@<Opcode Map Hook@>=
static const char* decode_opcode(uint8_t op) {
    switch (op) {
        case 0x01: return "PUSH";
        case 0x02: return "POP";
        case 0x03: return "ADD";
        case 0x04: return "SUB";
        case 0x05: return "MUL";
        case 0x06: return "DIV";
        case 0x07: return "MOD";
        case 0x08: return "NEG";
        case 0x09: return "ABS";
        case 0x0A: return "CMP3";
        case 0x10: return "JMP";
        case 0x11: return "JZ";
        case 0x12: return "JNZ";
        case 0x13: return "CALL";
        case 0x14: return "RET";
        case 0x20: return "TNN_ACCUM";
        case 0x21: return "T81_MATMUL";
        case 0x30: return "FACT";
        case 0x31: return "FIB";
        case 0x32: return "TOWER";
        case 0x33: return "ACK";
        case 0x34: return "BP";
        case 0xF0: return "PROMOTE_T243";
        case 0xF1: return "PROMOTE_T729";
        case 0xF2: return "DEMOTE_T243";
        case 0xF3: return "DEMOTE_T81";
        case 0xFF: return "HALT";
        default:   return "UNKNOWN";
    }
}

@<Disassembler Core Hook@>=
int disassemble_hvm_binary(const char* path, GhidraContext* ctx) {
    FILE* f = fopen(path, "rb");
    if (!f) return -1;

    uint64_t addr = ctx->base_addr;
    uint8_t op;

    while (fread(&op, 1, 1, f) == 1) {
        const char* opname = decode_opcode(op);
        ghidra_create_instruction(ctx, addr, opname);

        // Label symbolic macro entrypoints
        if (strcmp(opname, "FIB") == 0 || strcmp(opname, "FACT") == 0 || strcmp(opname, "TOWER") == 0) {
            ghidra_create_label(ctx, addr, opname);
        }

        if (strcmp(opname, "PUSH") == 0) {
            uint8_t tag;
            fread(&tag, 1, 1, f);
            ghidra_add_comment(ctx, addr, "T81 Typed Operand:");
            disasm_operand_by_tag(f, tag);  // full introspection including higher-order types
            addr += 1 + 1 + 9;  // op + tag + payload
        } else if (strcmp(opname, "TNN_ACCUM") == 0 || strcmp(opname, "T81_MATMUL") == 0) {
            fread(NULL, 1, 18, f);  // skip dual operands
            addr += 1 + 18;
        } else {
            addr += 1;
        }
    }

    fclose(f);
    return 0;
}

@<Plugin Entry Point@>=
int ghidra_plugin_main(const char* input_path, GhidraContext* ctx) {
    return disassemble_hvm_binary(input_path, ctx);
}
