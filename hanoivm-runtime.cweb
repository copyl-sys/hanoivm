@* hanoivm-runtime.cweb: HanoiVM Runtime Execution Engine for Ternary PCIe Accelerator

This module defines the HanoiVM interpreter for use in the Axion PCIe logic accelerator.
It executes T729 macros generated from T243 logic trees, encoded in Axionâ€™s ternary binary format (TBIN).

HanoiVM recursively interprets ternary instruction sets, operating on symbolic trits (-1, 0, 1)
and designed to run as the primary logic execution engine on the PCIe coprocessor.

@c
#include <stdint.h>
#include <stddef.h>
#include <string.h>

#define HANOIVM_MAX_STACK 64
#define HANOIVM_MEM_SIZE  81

// Ternary Opcodes (Must match Axion definitions)
#define TADD   0x01
#define TSUB   0x02
#define TMUL   0x03
#define TAND   0x04
#define TOR    0x05
#define TNOT   0x06
#define TJMP   0x07
#define TJZ    0x08
#define TJNZ   0x09
#define TLOAD  0x0A
#define TSTORE 0x0B
#define THLT   0x0C

// Trits are encoded as signed 8-bit integers: -1, 0, 1

typedef struct {
    int8_t reg[3];
    int8_t mem[HANOIVM_MEM_SIZE];
    uint8_t* code;
    size_t code_len;
    uint32_t ip;
    int8_t stack[HANOIVM_MAX_STACK];
    int sp;
    int running;
} hanoivm_state;

void hanoivm_reset(hanoivm_state* vm) {
    memset(vm->reg, 0, sizeof(vm->reg));
    memset(vm->mem, 0, sizeof(vm->mem));
    memset(vm->stack, 0, sizeof(vm->stack));
    vm->ip = 0;
    vm->sp = -1;
    vm->running = 1;
}

int hanoivm_exec(hanoivm_state* vm) {
    if (!vm || !vm->code || vm->code_len < 3) return -1;
    while (vm->running && vm->ip + 2 < vm->code_len) {
        uint8_t opcode = vm->code[vm->ip];
        int8_t a = (int8_t)vm->code[vm->ip + 1];
        int8_t b = (int8_t)vm->code[vm->ip + 2];
        
        switch (opcode) {
            case TADD:
                vm->reg[0] = (vm->reg[0] + a > 1) ? 1 : (vm->reg[0] + a < -1) ? -1 : vm->reg[0] + a;
                break;
            case TSUB:
                vm->reg[0] = (vm->reg[0] - a > 1) ? 1 : (vm->reg[0] - a < -1) ? -1 : vm->reg[0] - a;
                break;
            case TMUL:
                vm->reg[0] = (vm->reg[0] * a > 1) ? 1 : (vm->reg[0] * a < -1) ? -1 : vm->reg[0] * a;
                break;
            case TAND:
                vm->reg[0] = (vm->reg[0] < a) ? vm->reg[0] : a;
                break;
            case TOR:
                vm->reg[0] = (vm->reg[0] > a) ? vm->reg[0] : a;
                break;
            case TNOT:
                vm->reg[0] = -a;
                break;
            case TJMP:
                if (b != 0 && a * 3 < vm->code_len) vm->ip = a * 3 - 3; // -3 to neutralize next step
                break;
            case TJZ:
                if (b == 0 && a * 3 < vm->code_len) vm->ip = a * 3 - 3;
                break;
            case TJNZ:
                if (b != 0 && a * 3 < vm->code_len) vm->ip = a * 3 - 3;
                break;
            case TLOAD:
                if (a >= 0 && a < HANOIVM_MEM_SIZE && b >= 0 && b < 3) vm->reg[b] = vm->mem[a];
                break;
            case TSTORE:
                if (a >= 0 && a < HANOIVM_MEM_SIZE && b >= 0 && b < 3) vm->mem[a] = vm->reg[b];
                break;
            case THLT:
                vm->running = 0;
                break;
            default:
                return -2; // Unknown opcode
        }
        vm->ip += 3;
    }
    return 0;
}

@* 
This HanoiVM runtime module is optimized for PCIe co-execution with Axion AI + CUDA/GAIA layers.
It supports symbolic macro execution, stackless recursion, and ternary-specific operations.
Ready for integration with DMA-hosted memory and FPGA/GPU acceleration.
