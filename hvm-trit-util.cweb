/*
 * hvm-trit-util.cweb - Core Ternary Utility Library for HanoiVM Ecosystem
 *
 * This module provides base-81 optimized ternary arithmetic, parsing, and logical operations.
 * Designed for use across HanoiVM, Axion, Guardian AI, and associated subsystems.
 *
 * Author: Copyleft Systems
 * License: GPLv3
 */

#ifndef HVM_TRIT_UTIL_H
#define HVM_TRIT_UTIL_H

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <math.h>

#define BASE_81 81
#define T81_MMAP_THRESHOLD (500 * 1024)

/* Error Codes */
typedef enum {
    TRIT_OK = 0,
    TRIT_ERR_ALLOC,
    TRIT_ERR_INPUT,
    TRIT_ERR_DIV_ZERO,
    TRIT_ERR_OVERFLOW,
    TRIT_ERR_UNDEFINED,
    TRIT_ERR_NEGATIVE,
    TRIT_ERR_PRECISION,
    TRIT_ERR_MMAP,
    TRIT_ERR_SCRIPT
} TritError;

/* Big Integer Ternary */
typedef struct {
    int sign;
    uint8_t* digits;
    size_t len;
    int is_mapped;
    int fd;
    char tmp_path[32];
} T81BigInt;

/* Function Prototypes */
TritError parse_trit_string(const char* s, T81BigInt** out);
TritError t81bigint_to_trit_string(const T81BigInt* in, char** out);
TritError binary_to_trit(int num, T81BigInt** out);
TritError trit_to_binary(T81BigInt* x, int* outVal);
TritError tritjs_add_big(T81BigInt* A, T81BigInt* B, T81BigInt** result);
TritError tritjs_subtract_big(T81BigInt* A, T81BigInt* B, T81BigInt** result);
TritError tritjs_multiply_big(T81BigInt* A, T81BigInt* B, T81BigInt** result);
TritError tritjs_divide_big(T81BigInt* A, T81BigInt* B, T81BigInt** q, T81BigInt** r);
TritError tritjs_logical_and(T81BigInt* A, T81BigInt* B, T81BigInt** result);
TritError tritjs_logical_or(T81BigInt* A, T81BigInt* B, T81BigInt** result);
TritError tritjs_logical_not(T81BigInt* A, T81BigInt** result);
TritError tritjs_logical_xor(T81BigInt* A, T81BigInt* B, T81BigInt** result);
void tritbig_free(T81BigInt* x);

/* Initialization */
void init_trit_util();

#endif /* HVM_TRIT_UTIL_H */

#ifdef HVM_TRIT_UTIL_IMPL

#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

static TritError allocate_digits(T81BigInt *x, size_t lengthNeeded) {
    size_t bytesNeeded = (lengthNeeded == 0 ? 1 : lengthNeeded);
    x->len = lengthNeeded;
    x->is_mapped = 0;
    x->fd = -1;
    if (bytesNeeded < T81_MMAP_THRESHOLD) {
        x->digits = (uint8_t*)calloc(bytesNeeded, 1);
        if (!x->digits) return TRIT_ERR_ALLOC;
        return TRIT_OK;
    }
    strcpy(x->tmp_path, "/tmp/hvm_trit_util_XXXXXX");
    x->fd = mkstemp(x->tmp_path);
    if (x->fd < 0) return TRIT_ERR_MMAP;
    if (ftruncate(x->fd, bytesNeeded) < 0) {
        close(x->fd);
        return TRIT_ERR_MMAP;
    }
    x->digits = mmap(NULL, bytesNeeded, PROT_READ | PROT_WRITE, MAP_SHARED, x->fd, 0);
    if (x->digits == MAP_FAILED) {
        close(x->fd);
        return TRIT_ERR_MMAP;
    }
    unlink(x->tmp_path);
    x->is_mapped = 1;
    return TRIT_OK;
}

void tritbig_free(T81BigInt* x) {
    if (!x) return;
    if (x->is_mapped && x->digits && x->digits != MAP_FAILED) {
        munmap(x->digits, x->len);
        close(x->fd);
    } else {
        free(x->digits);
    }
    free(x);
}

TritError parse_trit_string(const char* s, T81BigInt** out) {
    if (!s || !out) return TRIT_ERR_INPUT;
    size_t len = strlen(s);
    *out = (T81BigInt*)calloc(1, sizeof(T81BigInt));
    if (!*out) return TRIT_ERR_ALLOC;
    int sign = 0;
    size_t pos = 0;
    if (s[0] == '-') { sign = 1; pos = 1; }
    TritError err = allocate_digits(*out, 1);
    if (err != TRIT_OK) return err;
    (*out)->digits[0] = 0;
    (*out)->sign = sign;
    for (; pos < len; pos++) {
        char c = s[pos];
        if (c < '0' || c > '2') {
            tritbig_free(*out);
            return TRIT_ERR_INPUT;
        }
        int digit = c - '0';
        int carry = digit;
        for (size_t i = 0; i < (*out)->len; i++) {
            int val = (*out)->digits[i] * 3 + carry;
            (*out)->digits[i] = val % BASE_81;
            carry = val / BASE_81;
        }
        while (carry) {
            size_t old_len = (*out)->len;
            err = allocate_digits(*out, old_len + 1);
            if (err != TRIT_OK) {
                tritbig_free(*out);
                return err;
            }
            (*out)->digits[old_len] = carry % BASE_81;
            carry /= BASE_81;
        }
    }
    return TRIT_OK;
}

TritError t81bigint_to_trit_string(const T81BigInt* in, char** out) {
    if (!in || !out) return TRIT_ERR_INPUT;
    T81BigInt tmp = *in;
    char* buf = (char*)calloc(tmp.len * 4 + 2, 1);
    if (!buf) return TRIT_ERR_ALLOC;
    size_t idx = 0;
    T81BigInt copy;
    memset(&copy, 0, sizeof(T81BigInt));
    if (allocate_digits(&copy, tmp.len) != TRIT_OK) {
        free(buf);
        return TRIT_ERR_ALLOC;
    }
    memcpy(copy.digits, tmp.digits, tmp.len);
    copy.len = tmp.len;
    while (copy.len > 0 && !(copy.len == 1 && copy.digits[0] == 0)) {
        int rem = 0;
        for (ssize_t i = copy.len - 1; i >= 0; i--) {
            int val = copy.digits[i] + rem * BASE_81;
            copy.digits[i] = val / 3;
            rem = val % 3;
        }
        buf[idx++] = '0' + rem;
        while (copy.len > 1 && copy.digits[copy.len - 1] == 0) copy.len--;
    }
    if (tmp.sign) buf[idx++] = '-';
    for (size_t i = 0; i < idx / 2; i++) {
        char t = buf[i];
        buf[i] = buf[idx - 1 - i];
        buf[idx - 1 - i] = t;
    }
    buf[idx] = '\0';
    *out = buf;
    return TRIT_OK;
}

TritError binary_to_trit(int num, T81BigInt** out) {
    char buffer[128];
    int sign = 0;
    size_t len = 0;
    if (num < 0) { sign = 1; num = -num; }
    if (num == 0) buffer[len++] = '0';
    while (num > 0) {
        buffer[len++] = '0' + (num % 3);
        num /= 3;
    }
    if (sign) buffer[len++] = '-';
    buffer[len] = '\0';
    for (size_t i = 0; i < len / 2; i++) {
        char tmp = buffer[i];
        buffer[i] = buffer[len - 1 - i];
        buffer[len - 1 - i] = tmp;
    }
    return parse_trit_string(buffer, out);
}

TritError trit_to_binary(T81BigInt* x, int* outVal) {
    if (!x || !outVal) return TRIT_ERR_INPUT;
    char* trit_str = NULL;
    if (t81bigint_to_trit_string(x, &trit_str) != TRIT_OK) return TRIT_ERR_INPUT;
    int val = 0;
    int sign = (trit_str[0] == '-') ? 1 : 0;
    for (size_t i = sign; trit_str[i]; i++) {
        if (trit_str[i] < '0' || trit_str[i] > '2') {
            free(trit_str);
            return TRIT_ERR_INPUT;
        }
        val = val * 3 + (trit_str[i] - '0');
    }
    if (sign) val = -val;
    *outVal = val;
    free(trit_str);
    return TRIT_OK;
}

void init_trit_util() {
    /* Future hooks for runtime context registration or debug tracing */
    fprintf(stderr, "[HanoiVM] Trit Utility Initialized.\n");
}

#endif /* HVM_TRIT_UTIL_IMPL */
