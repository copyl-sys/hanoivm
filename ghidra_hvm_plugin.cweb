@* Ghidra Plugin for HanoiVM â€” Disassembler & Type-Aware Processor Integration *@

@c
#include <ghidra/ghidra_plugin.h>
#include <ghidra/program.h>
#include <ghidra/disassembler.h>
#include "disasm_hvm.h"  // Full recursive type disassembler for T81 and higher-order types

#define T81_TAG_BIGINT     0x01
#define T81_TAG_FRACTION   0x02
#define T81_TAG_FLOAT      0x03
#define T81_TAG_MATRIX     0x04
#define T81_TAG_VECTOR     0x05
#define T81_TAG_TENSOR     0x06
#define T81_TAG_POLYNOMIAL 0x07
#define T81_TAG_GRAPH      0x08
#define T81_TAG_QUATERNION 0x09
#define T81_TAG_OPCODE     0x0A
#define GHIDRA_OUT stdout

void disasm_operand_by_tag(FILE *in, uint8_t tag) {
    switch (tag) {
        case T81_TAG_BIGINT:
            disasm_bigint(in); break;
        case T81_TAG_FRACTION:
            fprintf(GHIDRA_OUT, "T81Fraction { numerator: ");
            disasm_bigint(in);
            fprintf(GHIDRA_OUT, "  denominator: ");
            disasm_bigint(in);
            fprintf(GHIDRA_OUT, "}\n");
            break;
        case T81_TAG_FLOAT:
            fprintf(GHIDRA_OUT, "T81Float {\n  mantissa: ");
            disasm_bigint(in);
            int8_t exponent;
            fread(&exponent, 1, 1, in);
            fprintf(GHIDRA_OUT, "  exponent: %d\n}\n", exponent);
            break;
        case T81_TAG_GRAPH:
            disasm_graph(in); break;
        case T81_TAG_QUATERNION:
            disasm_quaternion(in); break;
        case T81_TAG_OPCODE:
            disasm_opcode(in); break;
        default:
            fprintf(GHIDRA_OUT, "UNKNOWN TYPE TAG 0x%02X\n", tag); break;
    }
}

@<Plugin Metadata@>=
GHIDRA_PLUGIN("HanoiVM Disassembler", "copyl-sys", "AI-native ternary instruction format disassembler")

@<Opcode Map Hook@>=
static const char* decode_opcode(uint8_t op) {
    switch (op) {
        case 0x01: return "PUSH";
        case 0x02: return "POP";
        case 0x03: return "ADD";
        case 0x04: return "SUB";
        case 0x05: return "MUL";
        case 0x06: return "DIV";
        case 0x07: return "MOD";
        case 0x08: return "NEG";
        case 0x09: return "ABS";
        case 0x0A: return "CMP3";
        case 0x10: return "JMP";
        case 0x11: return "JZ";
        case 0x12: return "JNZ";
        case 0x13: return "CALL";
        case 0x14: return "RET";
        case 0x20: return "TNN_ACCUM";
        case 0x21: return "T81_MATMUL";
        case 0x30: return "FACT";
        case 0x31: return "FIB";
        case 0x32: return "TOWER";
        case 0x33: return "ACK";
        case 0x34: return "BP";
        case 0xF0: return "PROMOTE_T243";
        case 0xF1: return "PROMOTE_T729";
        case 0xF2: return "DEMOTE_T243";
        case 0xF3: return "DEMOTE_T81";
        case 0xFF: return "HALT";
        default:   return "UNKNOWN";
    }
}

@<Disassembler Core Hook@>=
int disassemble_hvm_binary(const char* path, GhidraContext* ctx) {
    FILE* f = fopen(path, "rb");
    if (!f) return -1;

    uint64_t addr = ctx->base_addr;
    uint8_t op;

    while (fread(&op, 1, 1, f) == 1) {
        const char* opname = decode_opcode(op);
        ghidra_create_instruction(ctx, addr, opname);

        if (strcmp(opname, "FIB") == 0 || strcmp(opname, "FACT") == 0 || strcmp(opname, "TOWER") == 0) {
            ghidra_create_label(ctx, addr, opname);
        }

        if (strcmp(opname, "PUSH") == 0) {
            uint8_t tag;
            fread(&tag, 1, 1, f);
            ghidra_add_comment(ctx, addr, "T81 Typed Operand:");
            disasm_operand_by_tag(f, tag);
            addr += 1 + 1 + 9;
        } else if (strcmp(opname, "TNN_ACCUM") == 0 || strcmp(opname, "T81_MATMUL") == 0) {
            fread(NULL, 1, 18, f);
            addr += 1 + 18;
        } else {
            addr += 1;
        }
    }

    fclose(f);
    return 0;
}

@<Plugin Entry Point@>=
int ghidra_plugin_main(const char* input_path, GhidraContext* ctx) {
    return disassemble_hvm_binary(input_path, ctx);
}

@* Future Extension: Expand disasm_operand_by_tag() to support: *@
@c
void disasm_graph(FILE* in) {
    uint8_t node_count;
    fread(&node_count, 1, 1, in);
    fprintf(GHIDRA_OUT, "T81Graph [nodes=%d]\n", node_count);
    for (int i = 0; i < node_count; ++i) {
        uint8_t label_len;
        fread(&label_len, 1, 1, in);
        char label[32] = {0};
        fread(label, 1, label_len, in);
        fprintf(GHIDRA_OUT, "  Node[%d]: %s\n", i, label);
    }
    uint8_t edge_count;
    fread(&edge_count, 1, 1, in);
    fprintf(GHIDRA_OUT, "  Edges=%d\n", edge_count);
    for (int j = 0; j < edge_count; ++j) {
        uint8_t from, to;
        fread(&from, 1, 1, in);
        fread(&to, 1, 1, in);
        fprintf(GHIDRA_OUT, "    Edge: %d -> %d\n", from, to);
    }
}

void disasm_quaternion(FILE* in) {
    float q[4];
    fread(q, sizeof(float), 4, in);
    fprintf(GHIDRA_OUT, "T81Quaternion: [%.3f, %.3f, %.3f, %.3f]\n", q[0], q[1], q[2], q[3]);
}

void disasm_opcode(FILE* in) {
    uint8_t inner_op;
    fread(&inner_op, 1, 1, in);
    fprintf(GHIDRA_OUT, "T81SymbolicOpcode: 0x%02X (%s)\n", inner_op, decode_opcode(inner_op));
}
