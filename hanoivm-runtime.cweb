@* hanoivm-core.cweb | Recursive HanoiVM Runtime with Extended AI Integration *@
   This document defines the full HanoiVM runtime in Rust, integrated with T243 logic trees,
   T729 macro execution, and Axion AI support. Runtime behavior is synchronized with C-side
   configuration through `HanoiVMConfig` passed via FFI. This version introduces a bridge
   to the low-level C interpreter via an adapter and trit logic mirror.
@#

@<Use Statements@>=
use crate::libt81::{T81Digit, T81Number};
use crate::libt243::{T243Digit, T243LogicTree, T243Node};
use crate::libt729::{T729Digit, T729MacroEngine};
use crate::axion_ai::{axion_parse_command, axion_tbin_execute};
use crate::config::HanoiVMConfig;
use std::ffi::CStr;
use std::os::raw::{c_char, c_int};
@#

@<LowLevel Adapter@>=
/// Convert a low-level C VM state into a Rust HanoiVMCoreState struct
impl HanoiVMCoreState {
    pub fn from_raw_ptr(ptr: *const HanoiVMCoreState) -> Option<Self> {
        if ptr.is_null() {
            None
        } else {
            unsafe { Some(*ptr) }
        }
    }

    /// Convert the current low-level state to debug text
    pub fn debug_dump(&self) {
        println!("[CORE STATE] IP: {}, SP: {} | R0: {}, R1: {}, R2: {}", self.ip, self.sp, self.reg[0], self.reg[1], self.reg[2]);
    }
}

/// Convert a Rust HanoiVM to a low-level HanoiVMCoreState for C export
impl From<&HanoiVM> for HanoiVMCoreState {
    fn from(vm: &HanoiVM) -> Self {
        let mut mem = [0i8; 81];
        let mut stack = [0i8; 64];

        // Placeholder: Fill memory and stack from symbolic data if applicable later
        // For now, leave them zeroed

        HanoiVMCoreState {
            reg: [0, 0, 0],
            mem,
            ip: 0,
            sp: -1,
            stack,
        }
    }
}
/// Convert a low-level C VM state into a Rust HanoiVMCoreState struct
impl HanoiVMCoreState {
    pub fn from_raw_ptr(ptr: *const HanoiVMCoreState) -> Option<Self> {
        if ptr.is_null() {
            None
        } else {
            unsafe { Some(*ptr) }
        }
    }

    /// Convert the current low-level state to debug text
    pub fn debug_dump(&self) {
        println!("[CORE STATE] IP: {}, SP: {} | R0: {}, R1: {}, R2: {}", self.ip, self.sp, self.reg[0], self.reg[1], self.reg[2]);
    }
}


/// Represents a low-level ternary interpreter state compatible with the C runtime
#[repr(C)]
pub struct HanoiVMCoreState {
    pub reg: [i8; 3],
    pub mem: [i8; 81],
    pub ip: u32,
    pub sp: i32,
    pub stack: [i8; 64],
}

/// Helper to clamp values into trit space (-1, 0, 1)
pub fn clamp_trit(value: i32) -> i8 {
    if value > 1 {
        1
    } else if value < -1 {
        -1
    } else {
        value as i8
    }
}

/// Apply a basic opcode to the core state (TADD, TSUB, etc.)
pub fn apply_opcode(state: &mut HanoiVMCoreState, opcode: u8, a: i8, b: i8) {
    match opcode {
        0x01 => state.reg[0] = clamp_trit(state.reg[0] as i32 + a as i32), // TADD
        0x02 => state.reg[0] = clamp_trit(state.reg[0] as i32 - a as i32), // TSUB
        0x03 => state.reg[0] = clamp_trit(state.reg[0] as i32 * a as i32), // TMUL
        0x04 => state.reg[0] = state.reg[0].min(a),                        // TAND
        0x05 => state.reg[0] = state.reg[0].max(a),                        // TOR
        0x06 => state.reg[0] = -a,                                         // TNOT
        0x0D => { // TSPUSH
            if state.sp < 63 {
                state.sp += 1;
                state.stack[state.sp as usize] = state.reg[0];
            }
        }
        0x0E => { // TSPOP
            if state.sp >= 0 {
                state.reg[0] = state.stack[state.sp as usize];
                state.sp -= 1;
            }
        }
        _ => {}
    }
}
@#

@<Struct HanoiVM@>=
/// The core HanoiVM execution engine with configuration and AI control
pub struct HanoiVM {
    pub config: HanoiVMConfig,            // Shared runtime config
    pub macro_engine: T729MacroEngine,    // T729 macro dispatcher and storage
    pub frame_stack: Vec<T243LogicTree>,  // Execution stack
    pub output_log: Vec<T81Number>,       // Symbolic execution output
    pub ai_enabled: bool,                 // Toggle AI logic based on config
}
@#

@<Impl HanoiVM@>=
impl HanoiVM {
    pub fn new(config: HanoiVMConfig) -> Self {
        let ai = config.enable_anomaly_detection || config.enable_adaptive_mode_switching;
        HanoiVM {
            config,
            macro_engine: T729MacroEngine::new(),
            frame_stack: Vec::new(),
            output_log: Vec::new(),
            ai_enabled: ai,
        }
    }
    pub fn push_frame(&mut self, tree: T243LogicTree) {
        self.frame_stack.push(tree);
    }
    pub fn step(&mut self) -> Option<T81Number> {
        if let Some(frame) = self.frame_stack.pop() {
            if self.config.enable_debug_mode {
                println!("[TRACE] Executing step frame");
            }
            let mut result = frame.evaluate();
            if self.ai_enabled {
                result = axion_tbin_execute(result);
            }
            self.output_log.push(result.clone());
            Some(result)
        } else {
            None
        }
    }
    pub fn run(&mut self) {
        while let Some(frame) = self.frame_stack.pop() {
            if self.config.enable_debug_mode {
                println!("[TRACE] Running frame");
            }
            let mut result = frame.evaluate();
            if self.ai_enabled {
                result = axion_tbin_execute(result);
            }
            self.output_log.push(result);
        }
    }
    pub fn exec_macro(&mut self, digit: T729Digit, inputs: Vec<T81Number>) {
        if let Some(result) = self.macro_engine.execute(digit, inputs) {
            self.output_log.push(result);
        } else {
            eprintln!("[WARN] Undefined T729 macro at index: {}", digit.0);
        }
    }
    pub fn reset(&mut self) {
        self.frame_stack.clear();
        self.output_log.clear();
        self.macro_engine = T729MacroEngine::new();
        println!("HanoiVM runtime reset.");
    }
    pub fn final_output(&self) -> Option<&T81Number> {
        self.output_log.last()
    }
    pub fn trace(&self) {
        println!("== HanoiVM Execution Trace ==");
        for (i, out) in self.output_log.iter().enumerate() {
            println!("Step {}: {}", i, out);
        }
    }
    pub fn interact_with_ai(&mut self, cmd: &str) {
        axion_parse_command(cmd);
    }
    pub fn reoptimize_output(&mut self) {
        if self.ai_enabled {
            for result in self.output_log.iter_mut() {
                *result = axion_tbin_execute(result.clone());
            }
            println!("All outputs reoptimized using Axion AI.");
        } else {
            println!("AI optimizations are disabled.");
        }
    }
}
@#
