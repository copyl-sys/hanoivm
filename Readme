# HanoiVM

[![CI](https://github.com/copyl-sys/hanoivm/actions/workflows/ci.yml/badge.svg)](https://github.com/copyl-sys/hanoivm/actions/workflows/ci.yml)

A Ternary Virtual Machine ecosystem built for symbolic computation, recursive stack execution, and AI/GPU acceleration.

## ğŸ”§ Build Instructions

HanoiVM uses Bazel for hermetic builds:

```bash
bazel build //...
```

To run tests:

```bash
bazel test //...
```

## ğŸ§ª Run the Assembler

```bash
bazel run //:hvm_assembler -- input.asm output.hvm
```

Assembly input format:

```
PUSH 1 2 3
PUSH 4 5 6
ADD
```

## ğŸ–¥ï¸ Run hvmcli (Userspace to PCIe Interface)

```bash
bazel run //:hvmcli -- 01 1 2 3
```

This sends the opcode `0x01` (PUSH) with a ternary operand split into three base-27 segments: A=1, B=2, C=3.

The result of execution (if available) will be printed to the console.

## ğŸ”Œ Firmware Protocol

- `HVM_OPCODE_BUFFER`    â†’ PCIe-mapped 8-bit instruction register
- `HVM_OPERAND_BUFFER`   â†’ 81-bit (3x27-bit) operand region
- `HVM_CONTROL_REG`      â†’ Set to `1` to trigger execution
- `HVM_RESULT_BUFFER`    â†’ Read result from this after execution
- `HVM_STATUS_REG`       â†’ Will be `1` when result is ready

The firmware runs an infinite loop polling `HVM_CONTROL_REG`. Upon trigger, it executes the instruction via HanoiVM core logic and sets `HVM_STATUS_REG = 1`.

## ğŸš€ Components

- hvm_assembler â€” Converts ternary assembly to .hvm bytecode
- hvmcli        â€” Userspace interface to /dev/hvm0 (PCIe control)
- hvm_firmware  â€” Firmware entry point for ternary PCIe card
- hvm_pcie_driver â€” Linux PCIe kernel module

## ğŸ“¦ Artifacts

Generated .hvm bytecode is uploaded via CI in artifacts named hvm-output.

## ğŸ“š Licensing

MIT License. Copyright (c) 2025
