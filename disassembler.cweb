@* HanoiVM | Bytecode Disassembler â€” Extended with T81 Operand Support *@

@c
#include <stdio.h>
#include <stdint.h>
#include "advanced_ops.h"
#include "t81types.h"

extern uint8_t* hvm_code;
extern size_t hvm_code_size;

@* Fetch T81 ternary operand from byte stream *@
@c
uint81_t fetch_operand(const uint8_t* buf) {
    uint81_t out;
    out.a = ((uint32_t)buf[0] << 24) | ((uint32_t)buf[1] << 16) | ((uint32_t)buf[2] << 8) | buf[3];
    out.b = ((uint32_t)buf[4] << 24) | ((uint32_t)buf[5] << 16) | ((uint32_t)buf[6] << 8) | buf[7];
    out.c = buf[8];
    return out;
}

const char* opcode_to_str(uint8_t opcode) {
    return opcode_name(opcode);  // use unified name resolver
}

void disassemble_vm(void) {
    size_t ip = 0;
    while (ip < hvm_code_size) {
        uint8_t opcode = hvm_code[ip++];
        printf("%04zx: %-12s", ip - 1, opcode_to_str(opcode));

        switch (opcode) {
            case OP_PUSH:
            case OP_TNN_ACCUM:
            case OP_T81_MATMUL: {
                if (ip + 17 < hvm_code_size) {
                    uint81_t a = fetch_operand(&hvm_code[ip]);
                    uint81_t b = fetch_operand(&hvm_code[ip + 9]);
                    ip += 18;
                    printf(" A:%08X B:%08X C:%02X | A':%08X B':%08X C':%02X\n",
                        a.a, a.b, a.c, b.a, b.b, b.c);
                } else {
                    printf(" [truncated operands]\n");
                    return;
                }
                break;
            }
            default:
                printf("\n");
                break;
        }
    }
}

@h
void disassemble_vm(void);
