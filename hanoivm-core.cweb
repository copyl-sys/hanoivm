@* hanoivm-core.cweb | Recursive HanoiVM Runtime with Extended AI Integration *@
   This document defines the full HanoiVM runtime in Rust, integrated with T243 logic trees,
   T729 macro execution, and Axion AI support. Runtime behavior is synchronized with C-side
   configuration through `HanoiVMConfig` passed via FFI.
@#

@<Use Statements@>=
use crate::libt81::{T81Digit, T81Number};
use crate::libt243::{T243Digit, T243LogicTree, T243Node};
use crate::libt729::{T729Digit, T729MacroEngine};
use crate::axion_ai::{axion_parse_command, axion_tbin_execute};
use crate::config::HanoiVMConfig;
use std::ffi::CStr;
use std::os::raw::{c_char, c_int};
@#

@<Struct HanoiVM@>=
/// The core HanoiVM execution engine with configuration and AI control
pub struct HanoiVM {
    pub config: HanoiVMConfig,            // Shared runtime config
    pub macro_engine: T729MacroEngine,    // T729 macro dispatcher and storage
    pub frame_stack: Vec<T243LogicTree>,  // Execution stack
    pub output_log: Vec<T81Number>,       // Symbolic execution output
    pub ai_enabled: bool,                 // Toggle AI logic based on config
}
@#

@<Impl HanoiVM@>=
impl HanoiVM {
    pub fn new(config: HanoiVMConfig) -> Self {
        let ai = config.enable_anomaly_detection || config.enable_adaptive_mode_switching;
        HanoiVM {
            config,
            macro_engine: T729MacroEngine::new(),
            frame_stack: Vec::new(),
            output_log: Vec::new(),
            ai_enabled: ai,
        }
    }
    pub fn push_frame(&mut self, tree: T243LogicTree) {
        self.frame_stack.push(tree);
    }
    pub fn step(&mut self) -> Option<T81Number> {
        if let Some(frame) = self.frame_stack.pop() {
            if self.config.enable_debug_mode {
                println!("[TRACE] Executing step frame: {:?}", frame);
            }
            let mut result = frame.evaluate();
            if self.ai_enabled {
                result = axion_tbin_execute(result);
            }
            self.output_log.push(result.clone());
            Some(result)
        } else {
            None
        }
    }
    pub fn run(&mut self) {
        while let Some(frame) = self.frame_stack.pop() {
            if self.config.enable_debug_mode {
                println!("[TRACE] Running frame: {:?}", frame);
            }
            let mut result = frame.evaluate();
            if self.ai_enabled {
                result = axion_tbin_execute(result);
            }
            self.output_log.push(result);
        }
    }
    pub fn exec_macro(&mut self, digit: T729Digit, inputs: Vec<T81Number>) {
        if let Some(result) = self.macro_engine.execute(digit, inputs) {
            self.output_log.push(result);
        } else {
            eprintln!("[WARN] Undefined T729 macro at index: {}", digit.0);
        }
    }
    pub fn reset(&mut self) {
        self.frame_stack.clear();
        self.output_log.clear();
        self.macro_engine = T729MacroEngine::new();
        println!("HanoiVM runtime reset.");
    }
    pub fn final_output(&self) -> Option<&T81Number> {
        self.output_log.last()
    }
    pub fn trace(&self) {
        println!("== HanoiVM Execution Trace ==");
        for (i, out) in self.output_log.iter().enumerate() {
            println!("Step {}: {}", i, out);
        }
    }
    pub fn interact_with_ai(&mut self, cmd: &str) {
        axion_parse_command(cmd);
    }
    pub fn reoptimize_output(&mut self) {
        if self.ai_enabled {
            for result in self.output_log.iter_mut() {
                *result = axion_tbin_execute(result.clone());
            }
            println!("All outputs reoptimized using Axion AI.");
        } else {
            println!("AI optimizations are disabled.");
        }
    }
}
@#

@<FFI Bindings@>=
/// Exposed entrypoint for C FFI integration
#[no_mangle]
pub extern "C" fn execute_vm_from_c(config_ptr: *const HanoiVMConfig) -> c_int {
    if config_ptr.is_null() {
        eprintln!("[ERROR] Null configuration pointer received");
        return -1;
    }
    let config = unsafe { *config_ptr };
    let mut vm = HanoiVM::new(config);

    // NOTE: Frame construction must be passed from C in production use
    let dummy_frame = T243LogicTree::default();
    vm.push_frame(dummy_frame);
    vm.run();

    if let Some(out) = vm.final_output() {
        println!("[RESULT] Final output: {}", out);
        0
    } else {
        eprintln!("[ERROR] No output generated");
        1
    }
}
@#

@<hanoivm_core.h@>=
#ifndef HANOIVM_CORE_H
#define HANOIVM_CORE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "config.h"
#include <stdint.h>

// Execute HanoiVM from C, passing a runtime config pointer
int execute_vm_from_c(const struct HanoiVMConfig* config_ptr);

#ifdef __cplusplus
}
#endif

#endif // HANOIVM_CORE_H
@#

@<Main HanoiVM Runtime@>=
@<Use Statements@>
@<Struct HanoiVM@>
@<Impl HanoiVM@>
@<FFI Bindings@>
@<hanoivm_core.h@>
@#

@* End of hanoivm-core.cweb
   Defines the HanoiVM symbolic runtime environment with recursive execution,
   AI-assisted transformations, macro logic, introspective tracing, and full
   runtime configuration binding through the HanoiVMConfig interface.
   Also includes a C-callable entrypoint via `execute_vm_from_c()` and an
   embeddable `hanoivm_core.h` header for C/C++ integration.
@*
