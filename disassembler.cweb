@* HanoiVM | Bytecode Disassembler â€” Extended with T81 Operand Support, Extended Operand Types, and Verbose Hex Dump *@

@<Include Dependencies@>=
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include "advanced_ops.h"
#include "t81types.h"
@#

@<Define Verbose Flag and Macros@>=
#ifndef VERBOSE_DISASSEMBLE
  #define VERBOSE_DISASSEMBLE 0
#endif

#if VERBOSE_DISASSEMBLE
  #define VERBOSE_PRINT(...) printf(__VA_ARGS__)
  #define HEX_DUMP(buf, len) do {                    \
        for (size_t i = 0; i < (len); i++) {           \
            printf("%02X ", (buf)[i]);                 \
            if ((i+1) % 16 == 0) printf("\n");         \
        }                                              \
        if ((len) % 16 != 0) printf("\n");             \
    } while(0)
#else
  #define VERBOSE_PRINT(...)
  #define HEX_DUMP(buf, len)
#endif
@#

@<Global Bytecode Variables@>=
extern uint8_t* hvm_code;
extern size_t hvm_code_size;
@#

@<Fetch T81 Operand Function@>=
uint81_t fetch_operand(const uint8_t* buf) {
    uint81_t out;
    out.a = ((uint32_t)buf[0] << 24) | ((uint32_t)buf[1] << 16) | ((uint32_t)buf[2] << 8) | buf[3];
    out.b = ((uint32_t)buf[4] << 24) | ((uint32_t)buf[5] << 16) | ((uint32_t)buf[6] << 8) | buf[7];
    out.c = buf[8];
    return out;
}
@#

@<Opcode to String Translator@>=
const char* opcode_to_str(uint8_t opcode) {
    return opcode_name(opcode);  // Use unified name resolver (assumed to be defined)
}
@#

@<Extended Operand Disassembly@>=
/* Disassemble an operand based on its type tag.
   Future work: add cases for T81_TAG_VECTOR, T81_TAG_TENSOR, etc.
*/
void disasm_operand(FILE *in) {
    uint8_t tag;
    if (fread(&tag, 1, 1, in) != 1) {
        fprintf(stderr, "[ERROR] Unable to read operand type tag\n");
        return;
    }
    VERBOSE_PRINT("[DEBUG] Operand tag: 0x%02X\n", tag);
    switch (tag) {
        case T81_TAG_BIGINT: {
            uint8_t len;
            if (fread(&len, 1, 1, in) != 1) {
                fprintf(stderr, "[ERROR] Failed to read BIGINT length\n");
                return;
            }
            char buf[64] = {0};
            if (fread(buf, 1, len, in) != len) {
                fprintf(stderr, "[ERROR] Failed to read BIGINT value\n");
                return;
            }
            printf("BIGINT(%s)", buf);
            break;
        }
        case T81_TAG_FRACTION: {
            printf("FRACTION { numerator: ");
            disasm_operand(in);  // Recursively disassemble numerator
            printf(", denominator: ");
            disasm_operand(in);  // Then denominator
            printf(" }");
            break;
        }
        case T81_TAG_FLOAT: {
            printf("FLOAT { mantissa: ");
            disasm_operand(in);
            int8_t exponent;
            if (fread(&exponent, 1, 1, in) != 1) {
                fprintf(stderr, "[ERROR] Failed to read FLOAT exponent\n");
                return;
            }
            printf(", exponent: %d }", exponent);
            break;
        }
        case T81_TAG_GRAPH:
            printf("GRAPH { ... }"); break;
        case T81_TAG_QUATERNION:
            printf("QUATERNION { ... }"); break;
        case T81_TAG_OPCODE: {
            uint8_t inner;
            if (fread(&inner, 1, 1, in) != 1) {
                fprintf(stderr, "[ERROR] Failed to read inner opcode\n");
                return;
            }
            printf("OPCODE (inner): %s", opcode_to_str(inner));
            break;
        }
        default:
            printf("UNKNOWN TYPE TAG 0x%02X", tag);
            break;
    }
}
@#

@<Disassemble Core Function@>=
void disassemble_vm(void) {
    size_t ip = 0;
    
    if (!hvm_code) {
        printf("[ERROR] No bytecode loaded (hvm_code is NULL).\n");
        return;
    }
    
    /* Print header with total code size */
    printf("=== HanoiVM Disassembly ===\n");
    printf("Total Code Size: %zu bytes\n", hvm_code_size);
    printf("----------------------------\n");
    
    while (ip < hvm_code_size) {
        uint8_t opcode = hvm_code[ip++];
        printf("%04zx: %-12s", ip - 1, opcode_to_str(opcode));
        
#ifdef VERBOSE_DISASSEMBLE
        /* Print raw opcode byte */
        printf(" [Raw: %02X]", opcode);
#endif

        switch (opcode) {
            case OP_PUSH:
            case OP_TNN_ACCUM:
            case OP_T81_MATMUL: {
                /* Check that enough bytes exist for two operands (assumed 18 bytes total) */
                if (ip + 17 < hvm_code_size) {
#ifdef VERBOSE_DISASSEMBLE
                    printf(" | Operands Raw: ");
                    for (int j = 0; j < 18; j++)
                        printf("%02X ", hvm_code[ip + j]);
                    printf("\n");
#endif
                    uint81_t a = fetch_operand(&hvm_code[ip]);
                    uint81_t b = fetch_operand(&hvm_code[ip + 9]);
                    ip += 18;
                    printf(" A:%08X B:%08X C:%02X | A':%08X B':%08X C':%02X\n",
                        a.a, a.b, a.c, b.a, b.b, b.c);
                } else {
                    printf(" [truncated operands]\n");
                    return;
                }
                break;
            }
            /* Additional opcode cases can be added here for different operand lengths or types */
            default:
                printf("\n");
                break;
        }
    }
}
@#

@<Optional: Disassemble to File@>=
/* Optionally output the disassembly to a file for logging purposes */
void disassemble_to_file(const char* filename) {
    FILE* f = fopen(filename, "w");
    if (!f) {
        perror("fopen disassembly file");
        return;
    }
    /* Redirect stdout temporarily */
    FILE* orig = stdout;
    stdout = f;
    disassemble_vm();
    stdout = orig;
    fclose(f);
    printf("Disassembly written to %s\n", filename);
}
@#

@h
void disassemble_vm(void);
@#

@* End of disassembler.cweb
   This module now robustly disassembles HVM bytecode with extended operand processing,
   optional verbose hex dumps, and future extension hooks for additional operand types.
   The optional file output function facilitates logging and offline analysis.
@*
