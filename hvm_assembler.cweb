@* hvm_assembler.cweb - Assembles Ternary VM Assembly into .hvm Bytecode *@

@c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define MAX_LINE 128

@* Instruction format for T81 encoded instructions *@
@c
typedef struct {
    uint8_t opcode;
    uint32_t a, b, c;
} hvm_instruction;

@* Simple mnemonic to opcode translator *@
@c
uint8_t parse_opcode(const char* mnemonic) {
    if (strcmp(mnemonic, "NOP") == 0) return 0x00;
    if (strcmp(mnemonic, "PUSH") == 0) return 0x01;
    if (strcmp(mnemonic, "POP") == 0) return 0x02;
    if (strcmp(mnemonic, "ADD") == 0) return 0x03;
    // Extendable with more opcodes
    return 0xFF; // Unknown opcode
}

@* Main assembly loop: parse each line, write opcode + operand to binary file *@
@c
int main(int argc, char* argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <input.asm> <output.hvm>\n", argv[0]);
        return 1;
    }

    FILE* fin = fopen(argv[1], "r");
    FILE* fout = fopen(argv[2], "wb");
    if (!fin || !fout) {
        perror("file open error");
        return 1;
    }

    char line[MAX_LINE];
    while (fgets(line, sizeof(line), fin)) {
        if (line[0] == '#' || strlen(line) < 2) continue;

        char mnemonic[16];
        uint32_t a = 0, b = 0, c = 0;
        sscanf(line, "%15s %u %u %u", mnemonic, &a, &b, &c);

        uint8_t opcode = parse_opcode(mnemonic);
        if (opcode == 0xFF) {
            fprintf(stderr, "Unknown opcode: %s\n", mnemonic);
            continue;
        }

        fwrite(&opcode, 1, 1, fout);
        fwrite(&a, 4, 1, fout);
        fwrite(&b, 4, 1, fout);
        fwrite(&c, 4, 1, fout);
    }

    fclose(fin);
    fclose(fout);
    printf(".hvm file written to %s\n", argv[2]);
    return 0;
}

@* Unified Bazel Build System *@

@c
// WORKSPACE
workspace(name = "hanoivm")

load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

http_archive(
    name = "rules_cc",
    urls = ["https://github.com/bazelbuild/rules_cc/archive/refs/tags/0.0.9.zip"],
    strip_prefix = "rules_cc-0.0.9",
)

load("@rules_cc//cc:repositories.bzl", "rules_cc_dependencies")
rules_cc_dependencies()

@c
// BUILD.bazel at root level
load("@rules_cc//cc:defs.bzl", "cc_binary")

cc_binary(
    name = "hvm_assembler",
    srcs = ["assembler/hvm_assembler.c"],
    copts = ["-std=c99", "-Werror", "-Wall"],
    features = ["no_legacy_features"],
    visibility = ["//visibility:public"],
)

cc_binary(
    name = "hvmcli",
    srcs = ["cli/hvmcli.c"],
    copts = ["-std=c99"],
    visibility = ["//visibility:public"],
)

cc_binary(
    name = "hvm_firmware",
    srcs = ["firmware/hvm_firmware_entry.c"],
    copts = ["-std=c99"],
    visibility = ["//visibility:public"],
)

cc_binary(
    name = "hvm_pcie_driver",
    srcs = ["driver/hvm_pcie_driver.c"],
    copts = ["-std=gnu99"],
    visibility = ["//visibility:public"],
    linkshared = True,
)

sh_test(
    name = "hermetic_assembler_test",
    srcs = ["tests/hermetic_assembler_test.sh"],
    data = [":hvm_assembler"],
)

sh_test(
    name = "hermetic_cli_test",
    srcs = ["tests/hermetic_cli_test.sh"],
    data = [":hvmcli"],
)

sh_test(
    name = "hermetic_firmware_test",
    srcs = ["tests/hermetic_firmware_test.sh"],
    data = [":hvm_firmware"],
)

@* Hermetic Test Script (tests/hermetic_assembler_test.sh) *@

@c
#!/bin/bash
set -e
OUT=$(mktemp)
echo "PUSH 1 2 3" > input.asm
./hvm_assembler input.asm "$OUT"
hexdump -C "$OUT"

@* Hermetic Test Script (tests/hermetic_cli_test.sh) *@

@c
#!/bin/bash
set -e
./hvmcli 01 1 2 3

@* Hermetic Test Script (tests/hermetic_firmware_test.sh) *@

@c
#!/bin/bash
set -e
echo "(Simulated) Firmware interface loaded. No runtime test defined."
exit 0
