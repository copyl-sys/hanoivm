// t729tensor.cweb â€” T729Tensor Implementation

#include "ternary_base.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

typedef struct {
    int rank;
    int* shape;
    float* data; // placeholder flat tensor storage
} T729Tensor;

static size_t t729tensor_size(const T729Tensor* t) {
    size_t size = 1;
    for (int i = 0; i < t->rank; ++i)
        size *= t->shape[i];
    return size;
}

TernaryHandle t729tensor_new(int rank, const int* shape) {
    T729Tensor* tensor = (T729Tensor*)malloc(sizeof(T729Tensor));
    tensor->rank = rank;
    tensor->shape = (int*)malloc(sizeof(int) * rank);
    memcpy(tensor->shape, shape, sizeof(int) * rank);

    size_t size = t729tensor_size(tensor);
    tensor->data = (float*)calloc(size, sizeof(float));

    TernaryHandle h = { .base = BASE_729, .data = tensor };
    return h;
}

int t729tensor_contract(TernaryHandle a, TernaryHandle b, TernaryHandle* result) {
    // Simple dot-product for rank-1 vectors
    T729Tensor* A = (T729Tensor*)a.data;
    T729Tensor* B = (T729Tensor*)b.data;

    if (A->rank != 1 || B->rank != 1 || A->shape[0] != B->shape[0]) return -1;

    float dot = 0.0f;
    for (int i = 0; i < A->shape[0]; ++i)
        dot += A->data[i] * B->data[i];

    T729Tensor* out = (T729Tensor*)malloc(sizeof(T729Tensor));
    out->rank = 1;
    out->shape = (int*)malloc(sizeof(int));
    out->shape[0] = 1;
    out->data = (float*)malloc(sizeof(float));
    out->data[0] = dot;

    result->base = BASE_729;
    result->data = out;
    return 0;
}

int t729tensor_transpose(TernaryHandle h, TernaryHandle* result) {
    T729Tensor* t = (T729Tensor*)h.data;
    if (t->rank != 2) return -1; // Only support 2D transpose for now

    int rows = t->shape[0];
    int cols = t->shape[1];

    T729Tensor* out = (T729Tensor*)malloc(sizeof(T729Tensor));
    out->rank = 2;
    out->shape = (int*)malloc(sizeof(int) * 2);
    out->shape[0] = cols;
    out->shape[1] = rows;
    out->data = (float*)malloc(sizeof(float) * rows * cols);

    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            out->data[j * rows + i] = t->data[i * cols + j];
        }
    }

    result->base = BASE_729;
    result->data = out;
    return 0;
}

int t729tensor_reshape(TernaryHandle h, int new_rank, const int* new_shape, TernaryHandle* result) {
    T729Tensor* t = (T729Tensor*)h.data;
    size_t original_size = t729tensor_size(t);

    size_t new_size = 1;
    for (int i = 0; i < new_rank; ++i)
        new_size *= new_shape[i];

    if (new_size != original_size) return -1;

    T729Tensor* reshaped = (T729Tensor*)malloc(sizeof(T729Tensor));
    reshaped->rank = new_rank;
    reshaped->shape = (int*)malloc(sizeof(int) * new_rank);
    memcpy(reshaped->shape, new_shape, sizeof(int) * new_rank);
    reshaped->data = (float*)malloc(sizeof(float) * new_size);
    memcpy(reshaped->data, t->data, sizeof(float) * new_size);

    result->base = BASE_729;
    result->data = reshaped;
    return 0;
}

int t729tensor_slice(TernaryHandle h, int dim, int start, int end, TernaryHandle* result) {
    T729Tensor* t = (T729Tensor*)h.data;
    if (dim >= t->rank || start < 0 || end > t->shape[dim] || start >= end)
        return -1;

    int* new_shape = (int*)malloc(sizeof(int) * t->rank);
    memcpy(new_shape, t->shape, sizeof(int) * t->rank);
    new_shape[dim] = end - start;

    size_t stride = 1;
    for (int i = dim + 1; i < t->rank; ++i)
        stride *= t->shape[i];

    size_t slice_size = (end - start) * stride;
    float* new_data = (float*)malloc(sizeof(float) * slice_size);
    memcpy(new_data, t->data + start * stride, sizeof(float) * slice_size);

    T729Tensor* sliced = (T729Tensor*)malloc(sizeof(T729Tensor));
    sliced->rank = t->rank;
    sliced->shape = new_shape;
    sliced->data = new_data;

    result->base = BASE_729;
    result->data = sliced;
    return 0;
}

void t729tensor_free(TernaryHandle h) {
    T729Tensor* tensor = (T729Tensor*)h.data;
    if (tensor) {
        free(tensor->shape);
        free(tensor->data);
        free(tensor);
    }
}
