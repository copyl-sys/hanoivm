@* HanoiVM | VM Execution Engine with Advanced Ops Integration *@

@c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include "t81_stack.h"
#include "hvm_loader.h"
#include "ai_hook.h"
#include "advanced_ops.h"  // integrated opcodes and evaluation

@<Extern τ-registers@>=
extern int τ[28];  // τ0–τ26 + τ27 (Axion-reserved τ[27])

@<VM Context Definition@>=
typedef struct {
    size_t ip;           // Instruction pointer
    int halted;          // Halt flag
} HVMContext;

@<VM Execution API@>=
void execute_vm(void);

@* Ternary Operand Loader (reads 81-bit operand) *@
@c
uint81_t fetch_operand(const uint8_t* buf) {
    uint81_t out;
    out.a = ((uint32_t)buf[0] << 24) | ((uint32_t)buf[1] << 16) | ((uint32_t)buf[2] << 8) | buf[3];
    out.b = ((uint32_t)buf[4] << 24) | ((uint32_t)buf[5] << 16) | ((uint32_t)buf[6] << 8) | buf[7];
    out.c = buf[8];
    return out;
}

@* Stack Extensions for uint81_t support *@
@c
void push81u(uint81_t val) {
    push81(val.c);
    push81(val.b);
    push81(val.a);
}

uint81_t pop81u(void) {
    uint81_t val;
    val.a = pop81();
    val.b = pop81();
    val.c = pop81();
    return val;
}

@<VM Execution Function@>=

void execute_vm(void) {
    HVMContext ctx = { .ip = 0, .halted = 0 };

    while (!ctx.halted && ctx.ip < hvm_code_size) {
        uint8_t opcode = hvm_code[ctx.ip++];
        axion_signal(opcode);  // Notify Axion of opcode execution
        τ[AXION_REGISTER_INDEX] = axion_get_optimization();

        switch (opcode) {

            case OP_NOP:
                axion_log("NOP");
                break;

            case OP_PUSH: {
                if (ctx.ip + 8 >= hvm_code_size) {
                    fprintf(stderr, "[VM] PUSH missing operand!\n");
                    return;
                }
                uint81_t value = fetch_operand(&hvm_code[ctx.ip]);
                ctx.ip += 9;
                push81u(value);
                axion_log("PUSH" /* TODO: stringify value */);
                break;
            }

            case OP_ADD: add81(); axion_log("ADD"); break;
            case OP_SUB: sub81(); axion_log("SUB"); break;
            case OP_MUL: mul81(); axion_log("MUL"); break;
            case OP_DIV: div81(); axion_log("DIV"); break;
            case OP_MOD: mod81(); axion_log("MOD"); break;
            case OP_NEG: neg81(); axion_log("NEG"); break;
            case OP_ABS: abs81(); axion_log("ABS"); break;
            case OP_CMP3: cmp381(); axion_log("CMP3"); break;

            case OP_TNN_ACCUM:
            case OP_T81_MATMUL: {
                if (ctx.ip + 17 >= hvm_code_size) {
                    fprintf(stderr, "[VM] AI opcode missing operands!\n");
                    return;
                }
                uint81_t a = fetch_operand(&hvm_code[ctx.ip]);
                uint81_t b = fetch_operand(&hvm_code[ctx.ip + 9]);
                ctx.ip += 18;

                uint81_t result = evaluate_opcode(opcode, a, b);
                push81u(result);
                axion_log(opcode == OP_TNN_ACCUM ? "TNN_ACCUM" : "T81_MATMUL");
                break;
            }

            case OP_HALT:
                axion_log("HALT");
                ctx.halted = 1;
                break;

            default:
                fprintf(stderr, "[VM] Unknown opcode: 0x%02X at IP=%zu\n", opcode, ctx.ip - 1);
                return;
        }
    }
}

@h
@<VM Execution API@>
@<VM Context Definition@>
uint81_t fetch_operand(const uint8_t* buf);
void push81u(uint81_t val);
uint81_t pop81u(void);
