/* HanoiVM | Bytecode Disassembler â€” Extended with T81 Operand Support, Extended Operand Types, and Verbose Hex Dump */

@<Include Dependencies@>=
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include "advanced_ops.h"
#include "t81types.h"
#include "t81_types_support.h"
@#

@<Define Verbose Flag and Macros@>=
#ifndef VERBOSE_DISASSEMBLE
  #define VERBOSE_DISASSEMBLE 0
#endif

#if VERBOSE_DISASSEMBLE
  #define VERBOSE_PRINT(...) printf(__VA_ARGS__)
  #define HEX_DUMP(buf, len) do {                    \
        for (size_t i = 0; i < (len); i++) {           \
            printf("%02X ", (buf)[i]);                 \
            if ((i+1) % 16 == 0) printf("\n");         \
        }                                              \
        if ((len) % 16 != 0) printf("\n");             \
    } while(0)
#else
  #define VERBOSE_PRINT(...)
  #define HEX_DUMP(buf, len)
#endif
@#

@<Global Bytecode Variables@>=
extern uint8_t* hvm_code;
extern size_t hvm_code_size;
@#

@<Fetch T81 Operand Function@>=
uint81_t fetch_operand(const uint8_t* buf) {
    uint81_t out;
    out.a = ((uint32_t)buf[0] << 24) | ((uint32_t)buf[1] << 16) | ((uint32_t)buf[2] << 8) | buf[3];
    out.b = ((uint32_t)buf[4] << 24) | ((uint32_t)buf[5] << 16) | ((uint32_t)buf[6] << 8) | buf[7];
    out.c = buf[8];
    return out;
}
@#

@<Opcode to String Translator@>=
const char* opcode_to_str(uint8_t opcode) {
    switch (opcode) {
        case OP_TFADD:   return "TFADD";
        case OP_TFSUB:   return "TFSUB";
        case OP_TFLADD:  return "TFLADD";
        case OP_TFCOS:   return "TFCOS";
        case OP_TMMUL:   return "TMMUL";
        case OP_TVDOT:   return "TVDOT";
        case OP_TQMUL:   return "TQMUL";
        case OP_TPMUL:   return "TPMUL";
        case OP_TTCON:   return "TTCON";
        case OP_TGBFS:   return "TGBFS";
        default:         return opcode_name(opcode);
    }
}
@#

@<Extended Operand Disassembly@>=
void disasm_operand(FILE *in) {
    uint8_t tag;
    if (fread(&tag, 1, 1, in) != 1) {
        fprintf(stderr, "[ERROR] Unable to read operand type tag\n");
        return;
    }
    VERBOSE_PRINT("[DEBUG] Operand tag: 0x%02X\n", tag);
    switch (tag) {
        case T81_TAG_BIGINT: {
            uint8_t len;
            if (fread(&len, 1, 1, in) != 1) {
                fprintf(stderr, "[ERROR] Failed to read BIGINT length\n");
                return;
            }
            char buf[64] = {0};
            if (fread(buf, 1, len, in) != len) {
                fprintf(stderr, "[ERROR] Failed to read BIGINT value\n");
                return;
            }
            printf("BIGINT(%s)", buf);
            break;
        }
        case T81_TAG_FRACTION:
            printf("FRACTION { numerator: "); disasm_operand(in);
            printf(", denominator: "); disasm_operand(in); printf(" }"); break;
        case T81_TAG_FLOAT:
            printf("FLOAT { mantissa: "); disasm_operand(in);
            int8_t exponent;
            if (fread(&exponent, 1, 1, in) != 1) {
                fprintf(stderr, "[ERROR] Failed to read FLOAT exponent\n"); return;
            }
            printf(", exponent: %d }", exponent); break;
        case T81_TAG_VECTOR:
            printf("VECTOR { dim: ..., data: [...] }"); break;
        case T81_TAG_MATRIX:
            printf("MATRIX { shape: ..., values: [...] }"); break;
        case T81_TAG_TENSOR:
            printf("TENSOR { shape: [...], rank: ..., data: [...] }"); break;
        case T81_TAG_GRAPH:
            printf("GRAPH { nodes: ..., edges: ... }"); break;
        case T81_TAG_QUATERNION:
            printf("QUATERNION { x, y, z, w }"); break;
        case T81_TAG_OPCODE: {
            uint8_t inner;
            if (fread(&inner, 1, 1, in) != 1) {
                fprintf(stderr, "[ERROR] Failed to read inner opcode\n"); return;
            }
            printf("OPCODE (inner): %s", opcode_to_str(inner)); break;
        }
        default:
            printf("UNKNOWN TYPE TAG 0x%02X", tag); break;
    }
}
@#

@<Disassemble Core Function@>=
void disassemble_vm(void) {
    size_t ip = 0;

    if (!hvm_code) {
        printf("[ERROR] No bytecode loaded (hvm_code is NULL).\n");
        return;
    }

    printf("=== HanoiVM Disassembly ===\n");
    printf("Total Code Size: %zu bytes\n", hvm_code_size);
    printf("----------------------------\n");

    while (ip < hvm_code_size) {
        uint8_t opcode = hvm_code[ip++];
        printf("%04zx: %-12s", ip - 1, opcode_to_str(opcode));

#ifdef VERBOSE_DISASSEMBLE
        printf(" [Raw: %02X]", opcode);
#endif

        switch (opcode) {
            case OP_PUSH:
            case OP_TNN_ACCUM:
            case OP_T81_MATMUL: {
                if (ip + 17 < hvm_code_size) {
#ifdef VERBOSE_DISASSEMBLE
                    printf(" | Operands Raw: ");
                    for (int j = 0; j < 18; j++)
                        printf("%02X ", hvm_code[ip + j]);
                    printf("\n");
#endif
                    uint81_t a = fetch_operand(&hvm_code[ip]);
                    uint81_t b = fetch_operand(&hvm_code[ip + 9]);
                    ip += 18;
                    printf(" A:%08X B:%08X C:%02X | A':%08X B':%08X C':%02X\n",
                        a.a, a.b, a.c, b.a, b.b, b.c);
                } else {
                    printf(" [truncated operands]\n"); return;
                }
                break;
            }
            default:
                printf("\n"); break;
        }
    }
}
@#

@<Optional: Disassemble to File@>=
void disassemble_to_file(const char* filename) {
    FILE* f = fopen(filename, "w");
    if (!f) { perror("fopen disassembly file"); return; }
    FILE* orig = stdout;
    stdout = f;
    disassemble_vm();
    stdout = orig;
    fclose(f);
    printf("Disassembly written to %s\n", filename);
}
@#

@h
void disassemble_vm(void);
@#

@* End of disassembler.cweb */
