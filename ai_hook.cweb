@* HanoiVM | Axion AI Hook Interface

This CWEB module defines the Axion AI interface layer for the HanoiVM virtual machine.
Axion is an internal AI agent that:
- Monitors instruction usage
- Sends and receives optimization signals
- Logs metadata to support AI learning and runtime diagnostics

The AI hook interacts with the VM via register `τ27`, which is reserved exclusively for Axion use.
This module does not modify VM state directly, but provides signal and metadata
hooks for VM core logic to consume.

@c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <stdint.h>

@*1 Axion Constants and Globals

@<Axion Constants@>=
#define AXION_REGISTER_INDEX 27
#define AXION_LOG_FILE "axion.meta.json"

@<Axion Globals@>=
static int axion_enabled = 1;
static int axion_verbosity = 0;     // 0 = silent, 1 = log, 2 = debug
static int axion_last_signal = 0;
static FILE* axion_log_fp = NULL;

@*1 Axion API Function Declarations

@<Axion API Declarations@>=
void axion_log(const char* event);
void axion_log_event_json(const char* type, const char* message);
void axion_log_open(void);
void axion_log_close(void);

void axion_signal(uint8_t signal_code);
int  axion_get_optimization(void);
void axion_adjust_verbosity(int level);

@*1 Logging System (Human + JSON)

@<Axion Logging Functions@>=

void axion_log(const char* event) {
    if (axion_verbosity > 0) {
        printf("[Axion] LOG: %s\n", event);
    }
    axion_log_event_json("event", event);
}

void axion_log_open(void) {
    if (!axion_log_fp) {
        axion_log_fp = fopen(AXION_LOG_FILE, "a");
        if (!axion_log_fp) {
            fprintf(stderr, "[Axion] Error opening %s\n", AXION_LOG_FILE);
            return;
        }
    }
}

void axion_log_close(void) {
    if (axion_log_fp) {
        fclose(axion_log_fp);
        axion_log_fp = NULL;
    }
}

void axion_log_event_json(const char* type, const char* message) {
    if (axion_verbosity == 0) return;

    time_t now = time(NULL);
    char timestamp[32];
    strftime(timestamp, sizeof(timestamp), "%FT%T%z", localtime(&now));

    if (axion_verbosity > 1)
        printf("[Axion] JSON EVENT: %s - %s\n", type, message);

    axion_log_open();
    if (axion_log_fp) {
        fprintf(axion_log_fp,
                "{ \"type\": \"%s\", \"message\": \"%s\", \"time\": \"%s\" }\n",
                type, message, timestamp);
        fflush(axion_log_fp);
    }
}

@*1 Optimization and Signal Interface

@<Axion Signal Functions@>=

void axion_signal(uint8_t signal_code) {
    axion_last_signal = signal_code;
    if (axion_verbosity > 1)
        printf("[Axion] SIGNAL: code %d → τ[%d]\n", signal_code, AXION_REGISTER_INDEX);
}

int axion_get_optimization(void) {
    if (axion_verbosity > 1)
        printf("[Axion] GET: last_signal = %d\n", axion_last_signal);
    return axion_last_signal;
}

void axion_adjust_verbosity(int level) {
    axion_verbosity = level;
    printf("[Axion] Verbosity set to %d\n", level);
    char msg[64];
    snprintf(msg, sizeof(msg), "Verbosity set to %d", level);
    axion_log(msg);
}

@*1 Integration Example

This module expects the VM core to write `τ[27] = axion_get_optimization();` when needed,
and call `axion_signal(...)` when significant events (like opcodes) occur.

```c
// Inside your VM dispatch loop:
axion_signal(OP_ADD);
τ[AXION_REGISTER_INDEX] = axion_get_optimization();
```

@h
#ifndef AXION_HOOK_H
#define AXION_HOOK_H
#include <stdint.h>

#define AXION_REGISTER_INDEX 27

void axion_log(const char* event);
void axion_log_event_json(const char* type, const char* message);
void axion_log_open(void);
void axion_log_close(void);

void axion_signal(uint8_t signal_code);
int  axion_get_optimization(void);
void axion_adjust_verbosity(int level);

#endif
