@* hanoivm-core.cweb: Recursive HanoiVM Runtime with Extended AI Integration and Step Execution *@

@c
use crate::libt81::{T81Digit, T81Number};
use crate::libt243::{T243Digit, T243LogicTree, T243Node};
use crate::libt729::{T729Digit, T729MacroEngine};
use crate::axion_ai::{axion_parse_command, axion_tbin_execute}; // New AI-based functions

/// The recursive HanoiVM runtime instance
pub struct HanoiVM {
    pub macro_engine: T729MacroEngine, // T729 executor and registry
    pub frame_stack: Vec<T243LogicTree>, // Active execution frames
    pub output_log: Vec<T81Number>,      // Output from each step
    pub ai_enabled: bool,                // New field to control AI optimizations
}

impl HanoiVM {
    /// Initialize the HanoiVM with a macro engine, empty stack, and AI control
    pub fn new(ai_enabled: bool) -> Self {
        HanoiVM {
            macro_engine: T729MacroEngine::new(),
            frame_stack: Vec::new(),
            output_log: Vec::new(),
            ai_enabled,
        }
    }

    /// Load a new logic frame (T243 tree) onto the stack
    pub fn push_frame(&mut self, tree: T243LogicTree) {
        self.frame_stack.push(tree);
    }

    /// Execute the next frame on the stack (single step execution)
    pub fn step(&mut self) -> Option<T81Number> {
        if let Some(frame) = self.frame_stack.pop() {
            let mut result = frame.evaluate(); // T243Node → T81Number
            // If AI is enabled, perform introspective optimizations
            if self.ai_enabled {
                result = axion_tbin_execute(result); // Optimize using AI-driven transformation
            }
            self.output_log.push(result.clone());
            Some(result)
        } else {
            None
        }
    }

    /// Execute the entire frame stack recursively
    pub fn run(&mut self) {
        while let Some(frame) = self.frame_stack.pop() {
            let mut result = frame.evaluate(); // T243Node → T81Number

            // If AI is enabled, perform introspective optimizations
            if self.ai_enabled {
                result = axion_tbin_execute(result);
            }

            self.output_log.push(result);
        }
    }

    /// Execute a T729 macro by digit (high-level AI instruction)
    pub fn exec_macro(&mut self, digit: T729Digit, inputs: Vec<T81Number>) {
        if let Some(result) = self.macro_engine.execute(digit, inputs) {
            self.output_log.push(result);
        } else {
            eprintln!("[WARN] Undefined T729 macro at index: {}", digit.0);
        }
    }

    /// Reset the runtime: clear frame stack and output log, and reinitialize macro engine
    pub fn reset(&mut self) {
        self.frame_stack.clear();
        self.output_log.clear();
        self.macro_engine = T729MacroEngine::new();
        println!("HanoiVM runtime reset.");
    }

    /// Inspect the final output after recursive execution
    pub fn final_output(&self) -> Option<&T81Number> {
        self.output_log.last()
    }

    /// Print a full symbolic trace of the execution
    pub fn trace(&self) {
        println!("== HanoiVM Execution Trace ==");
        for (i, out) in self.output_log.iter().enumerate() {
            println!("Step {}: {}", i, out);
        }
    }

    /// Interact with Axion AI through the NLP command interface
    pub fn interact_with_ai(&mut self, cmd: &str) {
        axion_parse_command(cmd); // Execute AI commands like "optimize", "snapshot", etc.
    }

    /// Re-optimize all previous outputs using AI introspection
    pub fn reoptimize_output(&mut self) {
        if self.ai_enabled {
            for result in self.output_log.iter_mut() {
                *result = axion_tbin_execute(result.clone());
            }
            println!("All outputs reoptimized using Axion AI.");
        } else {
            println!("AI optimizations are disabled.");
        }
    }
}

@*
This module defines the full HanoiVM lifecycle:
- Stack-based recursive execution of T243 logic trees.
- Macro-instruction decoding through T729.
- Output monitoring and result tracing.
- Integration with Axion AI for introspective optimization and dynamic learning.
- Extended support for step-by-step execution, runtime reset, and reoptimization.
@*
