@* hanoivm-core.cweb | Recursive HanoiVM Runtime with AI & Debug Disassembly Integration *@
This document defines the core HanoiVM runtime, including:
- Symbolic execution (T81/T243/T729 logic),
- Axion AI interaction (entropy-aware),
- Session tracking,
- Low-level roundtrip verification,
- C-compatible FFI bridge,
- Now includes disassembler bridge for session-aware dumps.
@#

@<Use Statements@>=
use crate::libt81::{T81Digit, T81Number};
use crate::libt243::{T243Digit, T243LogicTree, T243Node};
use crate::libt729::{T729Digit, T729MacroEngine};
use crate::axion_ai::{axion_parse_command, axion_tbin_execute, axion_register_session};
use crate::config::HanoiVMConfig;
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int};
use uuid::Uuid;
@#

@<FFI Disassembler Bridge@>=
/// External C disassembler with session-aware output
extern "C" {
    fn disassemble_to_file_with_session(base: *const c_char, session_id: *const c_char);
}
@#

@<LowLevel Adapter@>=
/// Debug-only: Test full roundtrip and write trace logs
pub fn vm_roundtrip_test() {
    let mut vm = HanoiVM::new(HanoiVMConfig {
        enable_debug_mode: true,
        ..Default::default()
    });

    vm.output_log.push(T81Number([-1, 0, 1]));
    vm.output_log.push(T81Number([0, 1, -1]));

    println!("[ROUNDTRIP] Symbolic Execution:");
    vm.trace();

    // Write to trace.log
    use chrono::Local;
    let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
    let session_hash = format!("S{:x}", md5::compute(timestamp.as_bytes()));
    println!("[ROUNDTRIP] Timestamp: {} | Session: {}", timestamp, session_hash);
    if let Ok(mut file) = std::fs::OpenOptions::new().append(true).create(true).open("trace.log") {
        use std::io::Write;
        writeln!(file, "[ROUNDTRIP] Timestamp: {} | Session: {}", timestamp, session_hash).ok();
        for (i, out) in vm.output_log.iter().enumerate() {
            writeln!(file, "Step {}: {}", i, out).ok();
        }
    }

    // Roundtrip test: CoreState â†” HanoiVM
    let core_state = HanoiVMCoreState::from(&vm);
    core_state.debug_dump();
    if let Ok(mut file) = std::fs::OpenOptions::new()
        .append(true).create(true).open("trace.log") {
        use std::io::Write;
        writeln!(file, "[CORE STATE] IP: {}, SP: {} | R0: {}, R1: {}, R2: {}",
            core_state.ip, core_state.sp, core_state.reg[0], core_state.reg[1], core_state.reg[2]).ok();
    }

    let new_vm = HanoiVM::from(&core_state);
    println!("[ROUNDTRIP] Reconstructed HanoiVM:");
    new_vm.trace();
}
@#

@<Impl HanoiVM@>=
impl HanoiVM {
    /// Construct a new VM instance from a given config
    pub fn new(config: HanoiVMConfig) -> Self {
        let ai = config.enable_anomaly_detection || config.enable_adaptive_mode_switching;
        HanoiVM {
            config,
            macro_engine: T729MacroEngine::new(),
            frame_stack: Vec::new(),
            output_log: Vec::new(),
            ai_enabled: ai,
            session_id: format!("S-{}", Uuid::new_v4()),
        }
    }

    pub fn push_frame(&mut self, tree: T243LogicTree) {
        self.frame_stack.push(tree);
    }

    pub fn step(&mut self) -> Option<T81Number> {
        if let Some(frame) = self.frame_stack.pop() {
            if self.config.enable_debug_mode {
                println!("[TRACE] Executing step frame");
            }
            let mut result = frame.evaluate();
            if self.ai_enabled {
                result = axion_tbin_execute(result);
            }
            self.output_log.push(result.clone());
            Some(result)
        } else {
            None
        }
    }

    pub fn run(&mut self) {
        while let Some(frame) = self.frame_stack.pop() {
            if self.config.enable_debug_mode {
                println!("[TRACE] Running frame");
            }
            let mut result = frame.evaluate();
            if self.ai_enabled {
                result = axion_tbin_execute(result);
            }
            self.output_log.push(result);
        }
    }

    pub fn exec_macro(&mut self, digit: T729Digit, inputs: Vec<T81Number>) {
        if let Some(result) = self.macro_engine.execute(digit, inputs) {
            self.output_log.push(result);
        } else {
            eprintln!("[WARN] Undefined T729 macro at index: {}", digit.0);
        }
    }

    pub fn reset(&mut self) {
        self.frame_stack.clear();
        self.output_log.clear();
        self.macro_engine = T729MacroEngine::new();
        println!("HanoiVM runtime reset.");
    }

    pub fn final_output(&self) -> Option<&T81Number> {
        self.output_log.last()
    }

    pub fn trace(&self) {
        println!("== HanoiVM Execution Trace ==");
        for (i, out) in self.output_log.iter().enumerate() {
            println!("Step {}: {}", i, out);
        }
    }

    pub fn interact_with_ai(&mut self, cmd: &str) {
        println!("[Axion AI] [{}] >>> {}", self.session_id, cmd);
        axion_parse_command(cmd);
    }

    pub fn reoptimize_output(&mut self) {
        if self.ai_enabled {
            for result in self.output_log.iter_mut() {
                *result = axion_tbin_execute(result.clone());
            }
            println!("All outputs reoptimized using Axion AI.");
        } else {
            println!("AI optimizations are disabled.");
        }
    }
}
@#

@<Struct HanoiVM@>=
/// Symbolic VM runtime that tracks session and config
pub struct HanoiVM {
    pub config: HanoiVMConfig,
    pub macro_engine: T729MacroEngine,
    pub frame_stack: Vec<T243LogicTree>,
    pub output_log: Vec<T81Number>,
    pub ai_enabled: bool,
    pub session_id: String,
}
@#

@<C FFI Entry Point@>=
/// FFI entrypoint for HanoiVM execution from C side (PCIe/runtime)
#[no_mangle]
pub extern "C" fn execute_vm_from_c(config_ptr: *const HanoiVMConfig) -> c_int {
    if config_ptr.is_null() {
        eprintln!("[ERROR] Null configuration pointer received");
        return -1;
    }

    let config = unsafe { *config_ptr };
    let mut vm = HanoiVM::new(config);

    // Register session with Axion AI logging infrastructure
    axion_register_session(&vm.session_id);

    // Optional disassembler bridge
    if config.enable_debug_mode {
        println!("[DEBUG] Executing vm_roundtrip_test()...");
        vm_roundtrip_test();

        // Disassemble loaded bytecode to session-tagged file
        let base = CString::new("disasm").unwrap();
        let sid = CString::new(vm.session_id.clone()).unwrap();
        unsafe {
            disassemble_to_file_with_session(base.as_ptr(), sid.as_ptr());
        }
    }

    // Push a test frame (replace with loader logic)
    let dummy_frame = T243LogicTree::default();
    vm.push_frame(dummy_frame);
    vm.run();

    if let Some(out) = vm.final_output() {
        println!("[RESULT] Final output: {}", out);
        0
    } else {
        eprintln!("[ERROR] No output generated");
        1
    }
}
@#
